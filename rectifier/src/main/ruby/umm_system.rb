#--
# Copyright (c) 2012 Christopher C. Lamb
#
# SBIR DATA RIGHTS
# Contract No. FA8750-11-C-0195
# Contractor: AHS Engineering Services (under subcontract to Modus Operandi, Inc.)
# Address: 5909 Canyon Creek Drive NE, Albuquerque, NM 87111
# Expiration Date: 05/03/2018
# 
# The Governmentâ€™s rights to use, modify, reproduce, release, perform, display, 
# or disclose technical data or computer software marked with this legend are 
# restricted during the period shown as provided in paragraph (b) (4) 
# of the Rights in Noncommercial Technical Data and Computer Software-Small 
# Business Innovative Research (SBIR) Program clause contained in the above 
# identified contract. No restrictions apply after the expiration date shown 
# above. Any reproduction of technical data, computer software, or portions 
# thereof marked with this legend must also reproduce the markings.
#++
require 'set'
require 'rubygems/dependency_installer'

# These are our known dependencies.
dependencies = ['openssl', 'base64', 'isorelax', 'nokogiri']

# We will load and then attempt to require to check module load.
# We limit this to three attempts however.
$retry_limit = 3

# Module installer.
def require_or_install name
  $__retry_count__ = 0
  begin
    require name
  rescue LoadError => err
    puts "...loading #{name}..."
    Gem::DependencyInstaller.new.install name
    puts "done.\n"
    if $__retry_count__ <= $retry_limit
      $__retry_count__ = $__retry_count__ + 1
      puts "retrying require..."
      retry
    end
  end
end

# Checking dependencies.
dependencies.each { |dependency| require_or_install dependency }

class PolicyEvaluator

  # Stores the context generated by evaluating a DSL.
  attr_accessor :ctx

  # The actively processed policy.  We define this
  # as an object variable rather than passing it
  # from method to method.
  attr_accessor :active_policy

  # Initializing a DSL session.  The block contains the segment
  # to evaluate.
  def initialize name = 'default', &body
    ctx = {:name => name, :strategy => :all, :rules => []}
    self.ctx = {}
    instance_exec &body
  end

  # Handles the policy_set keyword.
  def policy_set name = nil, &body
    instance_exec &body
  end

  # Handles the policy keyword.
  def policy name, &body
    self.active_policy = {}
    instance_exec &body
    self.ctx[name] = self.active_policy
  end

  # Handles the include keyword.
  def include name
    rules = self.ctx[name]
    raise 'undefined referenced policy' if rules == nil
    self.active_policy = self.active_policy.merge rules
  end

  # Handles the match keyword.  The style is a label, one
  # of either :all, or :one.
  def match style
    self.active_policy[:style] = style
  end

  # Defines a rule.  The submitted block is ruby code
  # that is later evaluated against a context.
  def rule name, &body
    self.active_policy[name] = body
  end

end

class UsageManagementMechanism

  def execute? rules, ctx = {}, activity = :transmit

    failed_sections = Set.new

    rules.each do |rule_name, rule|
      ctx_value = ctx[rule_name]
      if ctx_value != nil
        evaluation = rule.call ctx_value.to_sym
        failed_sections.add rule_name if evaluation == false
      end
    end

    failed_sections.empty? ? true : false
  end
end

class ContentRectifier

  def initialize params
    @umm = params[:umm]
    # @syslog = Domain::ComponentFactory::instance.create_system_log self
    @strategy = params[:confidentiality_strategy] || :redact
  end

  def process args
    doc = Nokogiri::XML args[:artifact]
    policy_set = doc.xpath '//artifact/policy-set'
    #@syslog.info "policy set: #{policy_set.to_s}"
    return args[:artifact] if policy_set == nil || args[:context] == nil

    sections = doc.xpath '//artifact/data-object/content/section'

    evaluator = PolicyEvaluator.new do
      instance_eval(policy_set[0].content.to_s)
    end

    #@syslog.info "evaluator: #{evaluator.ctx.inspect}"
    sections.each do |section|
      policy_name = section.attr 'policy'
      #@syslog.info "policy: #{policy_name} \n context: #{args[:context]}"
      if @strategy == :redact
        section.remove unless @umm.execute? evaluator.ctx[policy_name.to_sym], args[:context], :transmit

      elsif @strategy == :encrypt

        key = 'This is going to be my 256-bit key.'
        iv = 'This is goig to be my 256-bit initialization vector.'
        
        # We've used AES-256-CBC, but that's under export control and requires
        # additional java configuration.  For simplicity, we have downgraded
        # to 128 bit encryption.
        type = 'AES-128-CBC'

        # This is essentially a small state machine.
        is_clear = @umm.execute? evaluator.ctx[policy_name.to_sym], args[:context], :transmit
        is_enciphered = section['status'] == 'encrypt'
        secure_line = is_enciphered && is_clear

        if is_enciphered 
          # decrypt; first remove base64 encoding, then decipher.
          edata64 = section.content
          edata = Base64.decode64 edata64
          content = decrypt edata, key, iv, type
          section.remove_attribute 'status'
          section.content = content
        end
        
        unless is_clear
          # encrypt; encipher, then apply base64 encoding.
          content = section.content
          edata = encrypt content, key, iv, type
          edata64 = Base64.encode64 edata
          section['status'] = 'encrypt'
          section.content = edata64
        end 
        
      end
    end
    doc.to_s
  end

  # Decrypts a block of data (encrypted_data) given an encryption key
  # and an initialization vector (iv).  Keys, iv's, and the data 
  # returned are all binary strings.  Cipher_type should be
  # "AES-256-CBC", "AES-256-ECB", or any of the cipher types
  # supported by OpenSSL.  Pass nil for the iv if the encryption type
  # doesn't use iv's (like ECB).  Returns a string.
  # * encrypted_data String 
  # * key String
  # * iv String
  # * cipher_type String  
  def decrypt encrypted_data, key, iv, cipher_type
    aes = OpenSSL::Cipher::Cipher.new cipher_type
    aes.decrypt
    aes.key = key
    aes.iv = iv if iv != nil
    aes.update(encrypted_data) + aes.final  
  end
  
  # Encrypts a block of data given an encryption key and an 
  # initialization vector (iv).  Keys, iv's, and the data returned 
  # are all binary strings.  Cipher_type should be "AES-256-CBC",
  # "AES-256-ECB", or any of the cipher types supported by OpenSSL.  
  # Pass nil for the iv if the encryption type doesn't use iv's (like
  # ECB).  Returns a string.
  # * data String 
  # * key String
  # * iv String
  # * cipher_type String  
  def encrypt data, key, iv, cipher_type
    aes = OpenSSL::Cipher::Cipher.new cipher_type
    aes.encrypt
    aes.key = key
    aes.iv = iv if iv != nil
    aes.update(data) + aes.final      
  end

end

class NilContentRectifier
  def process args
    # Domain::ComponentFactory::instance.create_system_log(self).info '...in NilContentRectifier...'
    args[:artifact]
  end
end
